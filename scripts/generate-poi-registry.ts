import fs from "node:fs/promises";
import path from "node:path";

type PoiRecord = {
  lat: number;
  lon: number;
};

type CityMeta = {
  id: string;
  center: { lat: number; lon: number };
  bbox: { minLat: number; minLon: number; maxLat: number; maxLon: number };
  fileName: string;
};

const CITY_PADDING = 0.05;
const ROUND_PRECISION = 4;

const round = (value: number) =>
  Number(value.toFixed(ROUND_PRECISION));

const clamp = (value: number, min: number, max: number) =>
  Math.min(max, Math.max(min, value));

const isValidLatLon = (lat: number, lon: number) =>
  Number.isFinite(lat) &&
  Number.isFinite(lon) &&
  Math.abs(lat) <= 90 &&
  Math.abs(lon) <= 180;

const readJsonFile = async (filePath: string) => {
  const raw = await fs.readFile(filePath, "utf8");
  return JSON.parse(raw) as unknown;
};

const loadCityMeta = async (filePath: string): Promise<CityMeta> => {
  const data = await readJsonFile(filePath);
  if (!Array.isArray(data) || data.length === 0) {
    throw new Error(`City dataset is empty: ${filePath}`);
  }

  const points = data as PoiRecord[];
  let count = 0;
  let sumLat = 0;
  let sumLon = 0;
  let minLat = Number.POSITIVE_INFINITY;
  let maxLat = Number.NEGATIVE_INFINITY;
  let minLon = Number.POSITIVE_INFINITY;
  let maxLon = Number.NEGATIVE_INFINITY;

  for (const item of points) {
    if (!item || typeof item !== "object") continue;
    const lat = Number((item as PoiRecord).lat);
    const lon = Number((item as PoiRecord).lon);
    if (!isValidLatLon(lat, lon)) {
      throw new Error(`Invalid lat/lon in ${filePath}`);
    }
    sumLat += lat;
    sumLon += lon;
    minLat = Math.min(minLat, lat);
    maxLat = Math.max(maxLat, lat);
    minLon = Math.min(minLon, lon);
    maxLon = Math.max(maxLon, lon);
    count += 1;
  }

  if (count === 0) {
    throw new Error(`City dataset has no valid coordinates: ${filePath}`);
  }

  const center = {
    lat: round(sumLat / count),
    lon: round(sumLon / count),
  };

  const bbox = {
    minLat: round(clamp(minLat - CITY_PADDING, -90, 90)),
    minLon: round(clamp(minLon - CITY_PADDING, -180, 180)),
    maxLat: round(clamp(maxLat + CITY_PADDING, -90, 90)),
    maxLon: round(clamp(maxLon + CITY_PADDING, -180, 180)),
  };

  const fileName = path.basename(filePath);
  const id = fileName.replace(/\.json$/i, "");

  return { id, center, bbox, fileName };
};

const writeRegistry = async () => {
  const root = process.cwd();
  const poisRoot = path.join(root, "src", "lib", "data", "pois");
  const countriesDir = path.join(poisRoot, "datasets", "countries");
  const citiesDir = path.join(poisRoot, "datasets", "cities");
  const outputPath = path.join(poisRoot, "registry.generated.ts");

  const [countryFiles, cityFiles] = await Promise.all([
    fs.readdir(countriesDir),
    fs.readdir(citiesDir),
  ]);

  const countryCodes = countryFiles
    .filter((file: string) => file.toLowerCase().endsWith(".json"))
    .map((file: string) => file.replace(/\.json$/i, ""))
    .map((code: string) => code.toUpperCase())
    .sort((a: string, b: string) => a.localeCompare(b));

  const cityMetaList = await Promise.all(
    cityFiles
      .filter((file: string) => file.toLowerCase().endsWith(".json"))
      .map((file: string) => loadCityMeta(path.join(citiesDir, file)))
  );

  cityMetaList.sort((a, b) => a.id.localeCompare(b.id));

  const countryEntries = countryCodes
    .map(
      (code: string) =>
        `  ${code}: async () => (await import("./datasets/countries/${code}.json")).default as POI[],`
    )
    .join("\n");

  const cityEntries = cityMetaList
    .map(
      (city) => `  "${city.id}": {
    id: "${city.id}",
    center: { lat: ${city.center.lat}, lon: ${city.center.lon} },
    bbox: { minLat: ${city.bbox.minLat}, minLon: ${city.bbox.minLon}, maxLat: ${city.bbox.maxLat}, maxLon: ${city.bbox.maxLon} },
    loader: async () => (await import("./datasets/cities/${city.fileName}")).default as POI[],
  },`
    )
    .join("\n");

  const output = `// This file is auto-generated by scripts/generate-poi-registry.ts
import type { POI } from "@/lib/types";
import type { Bbox, LatLon } from "@/lib/data/pois/utils";

export type CityDataset = {
  id: string;
  center: LatLon;
  bbox?: Bbox;
  loader: () => Promise<POI[]>;
};

export const countryDatasets: Record<string, () => Promise<POI[]>> = {
${countryEntries}
};

export const cityDatasets: Record<string, CityDataset> = {
${cityEntries}
};
`;

  await fs.writeFile(outputPath, output, "utf8");
  console.log(`Generated ${path.relative(root, outputPath)}`);
};

writeRegistry().catch((error) => {
  console.error(error);
  process.exit(1);
});
